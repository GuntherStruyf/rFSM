#+TITLE:	The rFSM Statecharts (beta)
#+AUTHOR:	Markus Klotzbuecher
#+EMAIL:	markus.klotzbuecher@mech.kuleuven.be
#+DATE:		[2011-01-12 Wed]
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:	en
#+OPTIONS:	H:3 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:	TeX:t LaTeX:nil skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT:	view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:
#+LINK_HOME:
#+XSLT:
##+STYLE:	<link rel="stylesheet" type="text/css" href="css/stylesheet.css" />

#+STARTUP:	showall
#+STARTUP:	hidestars

* Overview
  rFSM is a minimal Statechart variant designed for /Coordinating/
  complex systems such as robots. It is written purely in Lua and is
  thus highly portable and embeddable. Being a Lua domain specific
  language, rFSM inherits the easy extensibility of its host language.

  The following example shows a simple yet rather complete example

#+BEGIN_SRC lua
  -- any rFSM is always contained in a composite_state
  return rfsm.composite_staet:new {
     dbg = false, -- disable debugging

     -- this defines a composite state operational which contains two
     -- simple states
     operational = rfsm.composite_state:new{

	-- simple state which defines an enty function. The function is
	-- defined "in place".
	approaching = rfsm.simple_state:new{
	   entry=function () print("entering approaching state") end,
	},

	-- simple state which defines entry and exit. In contrast to the
	-- previous state these functions are defines outside of the
	-- statemachine.
	in_contact = rfsm.simple_state:new{
	   entry=enable_force_control,
	   exit=disable_force_control,
	},

	-- transitions are define between two states. Here only local
	-- states (at the same nesting level) are referenced. It is also
	-- possible to specify deeper nested states relative to the
	-- current position using a leading dot:
	-- .local_composte.simple_state
	rfsm.trans:new{ src='initial', tgt='approaching' },
	rfsm.trans:new{ src='approaching', tgt='in_contact', events={ 'e_contact_made' } },
	rfsm.trans:new{ src='in_contact', tgt='approaching', events={ 'e_contact_lost' } },
     },

     -- this simple state additionaly defines a doo state, which is
     -- executed while the state remains active. The boolean return
     -- value defines wheter the doo is idle, that is whether is shall
     -- be called again immediately or only after the next step
     -- iteration.
     safe = rfsm.simple_state:new{
	entry=safe_mode_enable, doo=safe_doo, exit=safe_mode_disable
     },

     rfsm.trans:new{ src='initial', tgt='safe' },
     rfsm.trans:new{ src='safe', tgt='operational', events={ 'e_range_clear' } },
     rfsm.trans:new{ src='operational', tgt='safe', events={ 'e_close_object' } },
  }
#+END_SRC

* API
*** Model entities

    | Function                | short alias   | description                                 |
    |-------------------------+---------------+---------------------------------------------+-
    | =simple_state:new{}=    | =sista:new{}= | create a simple state                       |
    | =composite_state:new{}= | =csta{}=      | create a composite state                    |
    | =connector:new{}=       | =conn:new{}=  | create a connector                          |
    | =transition:new{}=      | =trans:new{}= | create a transition                         |
    | =fsm rfsm.init(fsm)=    | none          | initialize a fsm and return initialized fsm |


    (these functions are part of the rfsm module, thus can be called
    in Lua with =rfsm.simple_state{}=)

    1. states (=simple_state= and =composite_state=) may define the
       following programs:

       =entry(fsm, state, 'entry')=
       =exit(fsm, state, 'entry')=

       Which will be called when the state is entered exited or exited
       respectively. The argument passed in are the toplevel
       statechart, the current state and the string 'entry'. The
       rationale behind the third argument is to allow one function to
       handle entry and exit and thus to be able to identify which one
       is being called.

       only simple states may additionaly define a do function (it is
       called =doo= in to avoid clashes with the identically named Lua
       keyword).

       =bool doo(fsm, state, 'doo')=

       This function is called repeatedly while a state remains
       active, that is no events trigger an outgoing transition. The
       bool returned defines wheter the doo is active or idle. In
       practice this means: if doo does not return true and there are
       no other events, doo will be called in a tight loop. If d

    3. connector: =connector=

    4. transitions: =transitions=

*** Operational API

    | Function            | description                    |
    |---------------------+--------------------------------|
    | =rfsm.step(fsm, n)= | attempt to transition FSM once |
    | =rfsm.run(fsm)=     | run FSM until it goes idle     |

    The =step= will attempt to step the given initialized fsm for n
    times. A step can either be a transition or a run of the doo
    program. Invoking =run= will call step as long as the fsm is not
    idle. Not idle means: there are events in the queue or there is an
    active =doo= function which is not idle.



*** Hook functions

    | function                 | description                                                                      |
    |--------------------------+----------------------------------------------------------------------------------|
    | =dbg=                    | called to output debug information. Set to false to disable. Default false.      |
    | =info=                   | called to output informational messages. Set to false to disable. Default stdout |
    | =warn=                   | called to output warnings. Set to false to disable. Default stderr.              |
    | =err=                    | called to output errors. Set to false to disable. Default stderr.                |
    | =table getevents()=      | function which returns a table of new events which have occured                  |
    | =dropevents(fsm, evtab)= | function is called with events which are discarded                               |
    | =step_hook(fsm)=         | is called for each step (mostly for debugging purposes)                          |
    | =idle_hook(fsm)=         | called *instead* of returning from step/run functions                            |

*
** Structural Model

   The rFSM state machine model is a minimal subset of UML2 and Harel
   Statecharts. It consists of the following four, main model elements:

       1) Simple state
       2) Composite state
       3) Transition
       4) Connector

   In addition two virtual model elements are introduced in order to
   simplify descriptions about different types of elements:

       - /States/ are either of simple state or composite state type.
       - /Nodes/ are either States or Connectors.

   A composite state is a state which can contain either other composite
   states or simple states. At the top-level any rFSM model is always
   contained in a top-level composite state. This way a state machine can
   immediately be composed by inserting it into a new composite state.

   In contrast to composite states /simple states/ can not contain any
   other states; they are leaves in the state machine tree. (This
   \emph{tree} is not to be confused with the state machine \emph{graph},
   in that the tree represents a hierarchy of decomposition, and not a
   map of the transitions that can take place between states.)
   Transitions connect Nodes in a directed fashion and carry a list of
   events which will trigger the transition. Transitions are owned by a
   composite state and not (as often assumed) by the state from which
   they originate.

   Connectors can be used to build complex transitions by interconnecting
   several elementary ones. This model element unifies the four very
   similar UML model elements junction, initial, entry- and exit
   pseudostates.

   While connectors can join together multiple transitions it is required
   that any complex transition must always start and end on a State.

   There exists one connector with special semantics: the initial
   connector. When a transition which ends on the boundary of a composite
   state is executed, the execution will continue with the transition
   emanating from the initial connector. Static checks assure that each
   composite state which is the target of a transition also contains a
   initial connector.

   Both States and transitions can be associated with programs. States
   may have entry and/or exit programs which are executed when the state
   is entered or left respectively. Simple states may in addition define
   a /do/ program which will be executed while the state is
   active. Transitions can define a guard condition and an =effect=
   program. The guard condition is executed when the transition is
   checked and can disable the transition if =false= is returned.  The
   =effect= function is executed when the transition is taken.

   This model is simple, structured and rich enough (in our modest
   opinion) (i) to serve most of the robot control use cases, even very
   complex ones, and (ii) to be integrate-able in KIF triples and code
   generation tools.

** Behavioral model

   In classical finite state automatons only one state may be active at a
   time. In contrast the Statecharts formalism allows multiple states to
   be active. The constraints under which this is allowed are:

   - for any active state its parent state must be active too
   - in a composite state only one child state may be active at a time

   A state-machine is executed for the first time by executing the
   transition starting from the initial connector which will result in
   the target state of this transition to be entered.

   The elementary way to advance the state machine is to invoke its
   =step= procedure. The step procedure will take *all* events which
   accumulated since the last step and attempt to find an enabled
   transition. This process starts top down, starting from the root
   composite state down to the active leaf simple state. As soon as a
   transition is found the searching is finished and the transition is
   executed.

   This approach of identifying the next transition has the advantage
   that it assigns explicit priorities (called /structural priorities/
   to transitions (higher to less deeply nested transitions) which are
   visible in the graphical representation. Given a set of events and
   the current active states of the state graph it is immediately
   visible which transition will be taken. (This follows the approach
   taken in STATEMATE semantics). Furthermore structural priority
   largely avoids conflicts among emanating transitions, leaving only
   the possibility of conflicts for transitions leaving a single
   state. These can be eliminated either by additional guard
   conditions or by means of explicitly defining their priorities
   (priority numbers).





** Advanced conceps


* Common pitfalls

  1. Name clashes between state/connector names with reserved Lua
     keywords.

     This can be worked around by using the following syntax:

     #+BEGIN_EXAMPLE
     ['end'] = rfsm.sista{...}
     #+END_EXAMPLE

  2. Executing functions accidentially

     It is a common mistake to execute externally defined functions
     instead of adding references to them:

     #+BEGIN_EXAMPLE
     stateX = rfsm.sista{ entry = my_func() }
     #+END_EXAMPLE

     The likely mistake above is to execute my_func and assing the
     result to entry instead of assigning my_func:

     #+BEGIN_EXAMPLE
     stateX = rfsm.sista{ entry = my_func }
     #+END_EXAMPLE

     Of course first example would be perfectly valid if my_func()
     returned a function as a result!

* Extensions
** Measuring transition latencies
* Tools
*** fsm2uml
*** fsmdbg

    Important: who wakes the rFSM when it hibernates? Various possibilites:

    - RTT triggers =updateHook()= after receiving a variable on a
      DataPort, which in turn can be used to call the fsm's =step()=
      function.

      - For debug purposes you can insert a sleep in the _idle_hook

      -

*** fsmpp
*** fsmtesting
* Internals
* Acknowledgement

  The research leading to these results has received funding from the
  European Community's Seventh Framework Programme (FP7/2007-2013)
  under grant agreement no. FP7-ICT-231940-BRICS (Best Practice in
  Robotics)
